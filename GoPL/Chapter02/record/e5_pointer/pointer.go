// 1. 变量是存储值的地方，指针的值是一个变量的地址。
// 2. 注意: 不是所有的值都有地址，但是所有的变量都有。
// 3. 使用指针，可以在无需知道变量名的情况下，间接读取或更新变量的值。
// 4. 如果一个变量声明为var x int，表达式&x(x的地址)获取一个指向整型
// 变量的指针，它的类型是整型指针(*int)。如果值为p，我们说p指向x，或
// 者p包含x的地址。p指向的变量写成*p。表达式*p获取变量的值，因为*p代
// 表一个变量，所以它可以出现在赋值操作符左边，用于更新变量的值。
// 5. 聚合类型变量的每个组成部分(结构体的成员或数组中的元素)都是变量，
// 所以也有一个地址。
// 6. 变量有时被描述为可寻址的值(变量有时候使用一个地址化的值)，表示
// 变量的表达式是唯一可以应用取地址操作符&的表达式。
// 7. 指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil
// 的情况下才相等。
// 8. 函数返回局部变量的地址是非常安全的。
// 9. 因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够
// 让函数更新间接传递的变量值。
// 10. 每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者
// 方式来标记同一变量。
// 11. 指针对于flag包是很关键的，它使用程序的命令行参数来设置
// 整个程序内某些变量的值。
// 12. echo4 这个例子中使用两个可选的标识参数:
// -n使echo忽略正常输出时结尾的换行符，-s sep使用sep替换默认参数输
// 出时使用的空格分隔符。
/*
>>> File Link:
../../demo/echo4/main.go
*/
package main

import "fmt"

func main() {
	x := 1
	p := &x         // p是整型指针，指向x
	fmt.Println(*p) // "1"
	*p = 2          // 等于 x = 2
	fmt.Println(x)  // 结果 "2"

	fmt.Println()
	compare()

	fmt.Println()
	fmt.Println(pp, *pp)
	// 每次调用f都会返回一个不同的值
	fmt.Println(f() == f()) // "false"
	fmt.Println(f(), f())

	fmt.Println()
	v := 1
	incr(&v)              // 副作用: v现在等于2
	fmt.Println(incr(&v)) // v现在等于3

}

func compare() {
	var x, y int
	var p *int

	// 如第7点所述
	fmt.Println(p != nil, &p != nil, p, &p)
	fmt.Println(&x == &x, &x == &y, &x == nil)
}

// 如第8点所述，通过调用f产生的局部变量v即使在调用返回后依然存在，
// 指针pp依然引用它。
var pp = f()

func f() *int {
	v := 1
	return &v
}

// 如第9点所述
func incr(p *int) int {
	*p++ // 递增p所指向的值；p自身保持不变
	return *p
}

/*
>>> Execution Result:
1
2

false true <nil> 0xc00000e038
true false false

0xc0000140d0 1
false
0xc000014108 0xc000014110

3
*/
